diff --git a/libloragw/inc/loragw_fpga.h b/libloragw/inc/loragw_fpga.h
new file mode 100644
index 0000000..f599f73
--- /dev/null
+++ b/libloragw/inc/loragw_fpga.h
@@ -0,0 +1,135 @@
+/*
+ / _____)             _              | |
+( (____  _____ ____ _| |_ _____  ____| |__
+ \____ \| ___ |    (_   _) ___ |/ ___)  _ \
+ _____) ) ____| | | || |_| ____( (___| | | |
+(______/|_____)_|_|_| \__)_____)\____)_| |_|
+  (C)2013 Semtech-Cycleo
+
+Description:
+    Functions used to handle FPGA register access for LoRa concentrator.
+    Registers are addressed by name.
+    Multi-bytes registers are handled automatically.
+    Read-modify-write is handled automatically.
+
+License: Revised BSD License, see LICENSE.TXT file include in the project
+Maintainer: Michael Coracin
+*/
+
+#ifndef _LORAGW_FPGA_REG_H
+#define _LORAGW_FPGA_REG_H
+
+/* -------------------------------------------------------------------------- */
+/* --- DEPENDANCIES --------------------------------------------------------- */
+
+#include <stdint.h>     /* C99 types */
+#include <stdbool.h>    /* bool type */
+
+/* -------------------------------------------------------------------------- */
+/* --- PUBLIC CONSTANTS ----------------------------------------------------- */
+
+#define LGW_REG_SUCCESS 0
+#define LGW_REG_ERROR -1
+
+#define LGW_MIN_NOTCH_FREQ      126000U /* 126 KHz */
+#define LGW_MAX_NOTCH_FREQ      250000U /* 250 KHz */
+#define LGW_DEFAULT_NOTCH_FREQ  129000U /* 129 KHz */
+
+/*
+auto generated register mapping for C code
+this file contains autogenerated C struct used to access the FPGA registers
+this file is autogenerated from registers description
+*/
+
+#define LGW_FPGA_SOFT_RESET 0
+#define LGW_FPGA_FEATURE 1
+#define LGW_FPGA_LBT_INITIAL_FREQ 2
+#define LGW_FPGA_VERSION 3
+#define LGW_FPGA_STATUS 4
+#define LGW_FPGA_CTRL_FEATURE_START 5
+#define LGW_FPGA_CTRL_RADIO_RESET 6
+#define LGW_FPGA_CTRL_INPUT_SYNC_I 7
+#define LGW_FPGA_CTRL_INPUT_SYNC_Q 8
+#define LGW_FPGA_CTRL_OUTPUT_SYNC 9
+#define LGW_FPGA_CTRL_INVERT_IQ 10
+#define LGW_FPGA_CTRL_ACCESS_HISTO_MEM 11
+#define LGW_FPGA_CTRL_CLEAR_HISTO_MEM 12
+#define LGW_FPGA_HISTO_RAM_ADDR 13
+#define LGW_FPGA_HISTO_RAM_DATA 14
+#define LGW_FPGA_HISTO_NB_READ 15
+#define LGW_FPGA_LBT_TIMESTAMP_CH 16
+#define LGW_FPGA_LBT_TIMESTAMP_SELECT_CH 17
+#define LGW_FPGA_LBT_CH0_FREQ_OFFSET 18
+#define LGW_FPGA_LBT_CH1_FREQ_OFFSET 19
+#define LGW_FPGA_LBT_CH2_FREQ_OFFSET 20
+#define LGW_FPGA_LBT_CH3_FREQ_OFFSET 21
+#define LGW_FPGA_LBT_CH4_FREQ_OFFSET 22
+#define LGW_FPGA_LBT_CH5_FREQ_OFFSET 23
+#define LGW_FPGA_LBT_CH6_FREQ_OFFSET 24
+#define LGW_FPGA_LBT_CH7_FREQ_OFFSET 25
+#define LGW_FPGA_SCAN_FREQ_OFFSET 26
+#define LGW_FPGA_LBT_SCAN_TIME_CH0 27
+#define LGW_FPGA_LBT_SCAN_TIME_CH1 28
+#define LGW_FPGA_LBT_SCAN_TIME_CH2 29
+#define LGW_FPGA_LBT_SCAN_TIME_CH3 30
+#define LGW_FPGA_LBT_SCAN_TIME_CH4 31
+#define LGW_FPGA_LBT_SCAN_TIME_CH5 32
+#define LGW_FPGA_LBT_SCAN_TIME_CH6 33
+#define LGW_FPGA_LBT_SCAN_TIME_CH7 34
+#define LGW_FPGA_RSSI_TARGET 35
+#define LGW_FPGA_HISTO_SCAN_FREQ 36
+#define LGW_FPGA_NOTCH_FREQ_OFFSET 37
+#define LGW_FPGA_TOTALREGS 38
+
+/* -------------------------------------------------------------------------- */
+/* --- PUBLIC FUNCTIONS PROTOTYPES ------------------------------------------ */
+
+/**
+@brief LoRa concentrator TX notch filter delay
+@return delay in microseconds introduced by TX notch filter
+*/
+float lgw_fpga_get_tx_notch_delay(void);
+
+/**
+@brief LoRa concentrator FPGA configuration
+@param tx_notch_freq TX notch filter frequency, in Hertz
+@return status of register operation (LGW_REG_SUCCESS/LGW_REG_ERROR)
+*/
+int lgw_fpga_configure(uint32_t tx_notch_freq);
+
+/**
+@brief LoRa concentrator FPGA register write
+@param register_id register number in the data structure describing registers
+@param reg_value signed value to write to the register (for u32, use cast)
+@return status of register operation (LGW_REG_SUCCESS/LGW_REG_ERROR)
+*/
+int lgw_fpga_reg_w(uint16_t register_id, int32_t reg_value);
+
+/**
+@brief LoRa concentrator FPGA register read
+@param register_id register number in the data structure describing registers
+@param reg_value pointer to a variable where to write register read value
+@return status of register operation (LGW_REG_SUCCESS/LGW_REG_ERROR)
+*/
+int lgw_fpga_reg_r(uint16_t register_id, int32_t *reg_value);
+
+/**
+@brief LoRa concentrator FPGA register burst write
+@param register_id register number in the data structure describing registers
+@param data pointer to byte array that will be sent to the LoRa concentrator
+@param size size of the transfer, in byte(s)
+@return status of register operation (LGW_REG_SUCCESS/LGW_REG_ERROR)
+*/
+int lgw_fpga_reg_wb(uint16_t register_id, uint8_t *data, uint16_t size);
+
+/**
+@brief LoRa concentrator FPGA register burst read
+@param register_id register number in the data structure describing registers
+@param data pointer to byte array that will be written from the LoRa concentrator
+@param size size of the transfer, in byte(s)
+@return status of register operation (LGW_REG_SUCCESS/LGW_REG_ERROR)
+*/
+int lgw_fpga_reg_rb(uint16_t register_id, uint8_t *data, uint16_t size);
+
+#endif
+/* --- EOF ------------------------------------------------------------------ */
diff --git a/libloragw/inc/loragw_hal.h b/libloragw/inc/loragw_hal.h
index 080867c..01d7eb3 100644
--- a/libloragw/inc/loragw_hal.h
+++ b/libloragw/inc/loragw_hal.h
@@ -44,6 +44,7 @@ License: Revised BSD License, see LICENSE.TXT file include in the project
 /* return status code */
 #define LGW_HAL_SUCCESS     0
 #define LGW_HAL_ERROR       -1
+#define LGW_LBT_ISSUE       1
 
 /* radio-specific parameters */
 #define LGW_XTAL_FREQU      32000000            /* frequency of the RF reference oscillator */
@@ -151,6 +152,9 @@ License: Revised BSD License, see LICENSE.TXT file include in the project
 /* Maximum size of Tx gain LUT */
 #define TX_GAIN_LUT_SIZE_MAX 16
 
+/* LBT constants */
+#define LBT_CHANNEL_FREQ_NB 8 /* Number of LBT channels */
+
 /* -------------------------------------------------------------------------- */
 /* --- PUBLIC TYPES --------------------------------------------------------- */
 
@@ -175,6 +179,27 @@ struct lgw_conf_board_s {
     uint8_t clksrc;         /*!> Index of RF chain which provides clock to concentrator */
 };
 
+/**
+@struct lgw_conf_lbt_chan_s
+@brief Configuration structure for LBT channels
+*/
+struct lgw_conf_lbt_chan_s {
+    uint32_t freq_hz;
+    uint16_t scan_time_us;
+};
+
+/**
+@struct lgw_conf_lbt_s
+@brief Configuration structure for LBT specificities
+*/
+struct lgw_conf_lbt_s {
+    bool                        enable;             /*!> enable or disable LBT */
+    int8_t                      rssi_target;        /*!> RSSI threshold to detect if channel is busy or not (dBm) */
+    uint8_t                     nb_channel;         /*!> number of LBT channels */
+    struct lgw_conf_lbt_chan_s  channels[LBT_CHANNEL_FREQ_NB];
+    int8_t                      rssi_offset;        /*!> RSSI offset to be applied to SX127x RSSI values */
+};
+
 /**
 @struct lgw_conf_rxrf_s
 @brief Configuration structure for a RF chain
@@ -185,6 +210,7 @@ struct lgw_conf_rxrf_s {
     float                   rssi_offset;    /*!> Board-specific RSSI correction factor */
     enum lgw_radio_type_e   type;           /*!> Radio type for that RF chain (SX1255, SX1257....) */
     bool                    tx_enable;      /*!> enable or disable TX on that RF chain */
+    uint32_t                tx_notch_freq;  /*!> TX notch filter frequency [126KHz..250KHz] */
 };
 
 /**
@@ -387,6 +413,12 @@ int lgw_mcu_version_info(void);
 */
 uint32_t lgw_time_on_air(struct lgw_pkt_tx_s *packet);
 
+extern uint8_t lgwx_device_mode;
+extern uint8_t lgwx_beacon_len;
+extern uint8_t lgwx_beacon_sf;
+extern uint8_t lgwx_lbt_mode;
+enum { LGWX_LBT_MODE_DFLT=0, LGWX_LBT_MODE_OFF = 1 };
+
 #endif
 
 /* --- EOF ------------------------------------------------------------------ */
diff --git a/libloragw/inc/loragw_lbt.h b/libloragw/inc/loragw_lbt.h
new file mode 100644
index 0000000..aa04060
--- /dev/null
+++ b/libloragw/inc/loragw_lbt.h
@@ -0,0 +1,73 @@
+/*
+ / _____)             _              | |
+( (____  _____ ____ _| |_ _____  ____| |__
+ \____ \| ___ |    (_   _) ___ |/ ___)  _ \
+ _____) ) ____| | | || |_| ____( (___| | | |
+(______/|_____)_|_|_| \__)_____)\____)_| |_|
+  (C)2013 Semtech-Cycleo
+
+Description:
+    Functions used to handle the Listen Before Talk feature
+
+License: Revised BSD License, see LICENSE.TXT file include in the project
+Maintainer: Michael Coracin
+*/
+
+#ifndef _LORAGW_LBT_H
+#define _LORAGW_LBT_H
+
+/* -------------------------------------------------------------------------- */
+/* --- DEPENDANCIES --------------------------------------------------------- */
+
+#include <stdint.h>     /* C99 types */
+#include <stdbool.h>    /* bool type */
+
+#include "loragw_hal.h"
+
+/* -------------------------------------------------------------------------- */
+/* --- PUBLIC CONSTANTS ----------------------------------------------------- */
+
+#define LGW_LBT_SUCCESS 0
+#define LGW_LBT_ERROR -1
+
+// Originally in loragw_hal.h
+int lgw_lbt_setconf(struct lgw_conf_lbt_s conf);
+
+/* -------------------------------------------------------------------------- */
+/* --- PUBLIC FUNCTIONS PROTOTYPES ------------------------------------------ */
+
+/**
+@brief Set the configuration parameters for LBT feature
+@param conf structure containing the configuration parameters
+@return LGW_LBT_ERROR id the operation failed, LGW_LBT_SUCCESS else
+*/
+int lbt_setconf(struct lgw_conf_lbt_s * conf);
+
+/**
+@brief Configure the concentrator for LBT feature
+@return LGW_LBT_ERROR id the operation failed, LGW_LBT_SUCCESS else
+*/
+int lbt_setup(void);
+
+/**
+@brief Start the LBT FSM
+@return LGW_LBT_ERROR id the operation failed, LGW_LBT_SUCCESS else
+*/
+int lbt_start(void);
+
+/**
+@brief Configure the concentrator for LBT feature
+@param pkt_data pointer to downlink packet to be trabsmitted
+@param tx_allowed pointer to receive permission for transmission
+@return LGW_LBT_ERROR id the operation failed, LGW_LBT_SUCCESS else
+*/
+int lbt_is_channel_free(struct lgw_pkt_tx_s * pkt_data, uint16_t tx_start_delay, bool * tx_allowed);
+
+/**
+@brief Check if LBT is enabled
+@return true if enabled, false otherwise
+*/
+bool lbt_is_enabled(void);
+
+#endif
+/* --- EOF ------------------------------------------------------------------ */
diff --git a/libloragw/src/loragw_hal.c b/libloragw/src/loragw_hal.c
index 2c46381..a4e4b85 100644
--- a/libloragw/src/loragw_hal.c
+++ b/libloragw/src/loragw_hal.c
@@ -225,11 +225,18 @@ int load_firmware(uint8_t target, uint8_t *firmware, uint16_t size) {
 
 /* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
 
+uint8_t lgwx_device_mode = 0;
+uint8_t lgwx_beacon_len = 0;
+uint8_t lgwx_beacon_sf = 0;
+uint8_t lgwx_lbt_mode = 0;
+
 void lgw_constant_adjust(void) {
 
     /* I/Q path setup */
     // lgw_reg_w(LGW_RX_INVERT_IQ,0); /* default 0 */
     // lgw_reg_w(LGW_MODEM_INVERT_IQ,1); /* default 1 */
+    if( lgwx_device_mode )
+        lgw_reg_w(LGW_MODEM_INVERT_IQ,0);
     // lgw_reg_w(LGW_CHIRP_INVERT_RX,1); /* default 1 */
     // lgw_reg_w(LGW_RX_EDGE_SELECT,0); /* default 0 */
     // lgw_reg_w(LGW_MBWSSF_MODEM_INVERT_IQ,0); /* default 0 */
@@ -279,6 +286,8 @@ void lgw_constant_adjust(void) {
 
     // lgw_reg_w(LGW_PREAMBLE_FINE_TIMING_GAIN,1); /* default 1 */
     // lgw_reg_w(LGW_ONLY_CRC_EN,1); /* default 1 */
+    if( lgwx_device_mode )
+        lgw_reg_w(LGW_ONLY_CRC_EN,0);
     // lgw_reg_w(LGW_PAYLOAD_FINE_TIMING_GAIN,2); /* default 2 */
     // lgw_reg_w(LGW_TRACKING_INTEGRAL,0); /* default 0 */
     // lgw_reg_w(LGW_ADJUST_MODEM_START_OFFSET_RDX8,0); /* default 0 */
@@ -299,11 +308,24 @@ void lgw_constant_adjust(void) {
         lgw_reg_w(LGW_MBWSSF_FRAME_SYNCH_PEAK2_POS, 2); /* default 2 */
     }
     // lgw_reg_w(LGW_MBWSSF_ONLY_CRC_EN,1); /* default 1 */
+    if( lgwx_device_mode )
+        lgw_reg_w(LGW_MBWSSF_ONLY_CRC_EN,0);
     // lgw_reg_w(LGW_MBWSSF_PAYLOAD_FINE_TIMING_GAIN,2); /* default 2 */
     // lgw_reg_w(LGW_MBWSSF_PREAMBLE_FINE_TIMING_GAIN,1); /* default 1 */
     // lgw_reg_w(LGW_MBWSSF_TRACKING_INTEGRAL,0); /* default 0 */
     // lgw_reg_w(LGW_MBWSSF_AGC_FREEZE_ON_DETECT,1); /* default 1 */
 
+    if( lgwx_device_mode && lgwx_beacon_len ) {
+        lgw_reg_w(LGW_MBWSSF_MODEM_INVERT_IQ,0);
+        lgw_reg_w(LGW_MBWSSF_RATE_SF, lgwx_beacon_sf);
+        lgw_reg_w(LGW_MBWSSF_IMPLICIT_HEADER,1); /* no header */
+        lgw_reg_w(LGW_MBWSSF_IMPLICIT_CRC_EN,0);
+        lgw_reg_w(LGW_MBWSSF_IMPLICIT_CODING_RATE,1);
+        lgw_reg_w(LGW_MBWSSF_IMPLICIT_PAYLOAD_LENGHT, lgwx_beacon_len);
+    } else {
+        lgw_reg_w(LGW_MBWSSF_MODEM_INVERT_IQ,1); //XXX:? correct?
+    }
+
     /* Improvement of reference clock frequency error tolerance */
     lgw_reg_w(LGW_ADJUST_MODEM_START_OFFSET_RDX4, 1); /* default 0 */
     lgw_reg_w(LGW_ADJUST_MODEM_START_OFFSET_SF12_RDX4, 4094); /* default 4092 */
@@ -587,6 +609,11 @@ int lgw_board_setconf(struct lgw_conf_board_s conf) {
     return lgw_mcu_board_setconf(conf);
 }
 
+int lgw_lbt_setconf (struct lgw_conf_lbt_s conf) {
+    (void) conf;
+    return LGW_HAL_ERROR;
+}
+
 /* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
 
 int lgw_rxrf_setconf(uint8_t rf_chain, struct lgw_conf_rxrf_s conf) {
@@ -1154,6 +1181,11 @@ int lgw_send(struct lgw_pkt_tx_s pkt_data) {
         return LGW_HAL_ERROR;
     }
 
+    if( lgwx_device_mode ) {
+        pkt_data.invert_pol = false;
+        pkt_data.no_crc = false;
+    }
+
     /* send packet data to concentrator MCU */
     return lgw_mcu_send(pkt_data);
 }
diff --git a/libloragw/src/loragw_com_linux.c b/libloragw/src/loragw_com_linux.c
index 4ef7e37..d708321 100644
--- a/libloragw/src/loragw_com_linux.c
+++ b/libloragw/src/loragw_com_linux.c
@@ -205,6 +205,7 @@ int lgw_com_receive_ans_linux(lgw_com_ans_t *ans, lgw_handle_t handle) {
     size_t cmd_size;
     ssize_t buf_size = 0;
     ssize_t lencheck;
+    int readtries = 0;
 
     /* Initialize variables */
     memset(bufferrx, 0, sizeof bufferrx);
@@ -213,8 +214,17 @@ int lgw_com_receive_ans_linux(lgw_com_ans_t *ans, lgw_handle_t handle) {
     buffer_idx = 0;
     while ((checkcmd_linux(bufferrx[0]) != true) || (buffer_idx < CMD_HEADER_RX_SIZE)) {
         lencheck = read(handle, &bufferrx[buffer_idx], CMD_HEADER_RX_SIZE - buffer_idx);
-        if (lencheck < 0) {
-            DEBUG_PRINTF("WARNING: failed to read from communication bridge (%d - %s), retry...\n", errno, strerror(errno));
+        if (lencheck==0) {
+            // In case of non-blocking IO we may get 0 bytes back
+            if( ++readtries > 4 ) {
+                printf("ERROR: failed to read from communication bridge - no data\n");
+                return LGW_COM_ERROR;
+            }
+            wait_ns_linux(250000);
+        }
+        else if (lencheck < 0) {
+            //DEBUG_PRINTF("WARNING: failed to read from communication bridge (%d - %s), retry...\n", errno, strerror(errno));
+            printf("ERROR: failed to read from communication bridge (%d - %s), retry...\n", errno, strerror(errno));
             return LGW_COM_ERROR;
         }
         buffer_idx += lencheck;
@@ -266,9 +276,7 @@ int lgw_com_receive_ans_linux(lgw_com_ans_t *ans, lgw_handle_t handle) {
 int lgw_com_open_linux(void **com_target_ptr, const char *com_path) {
 
     int *usb_device = NULL;
-    char portname[50];
-    int x;
-    int fd;
+    int fd = -1;
 
     /*check input variables*/
     CHECK_NULL(com_target_ptr);
@@ -280,26 +288,36 @@ int lgw_com_open_linux(void **com_target_ptr, const char *com_path) {
     }
 
     /* open tty port */
-    sprintf(portname, "%s", com_path);
-    fd = open(portname, O_RDWR | O_NOCTTY | O_SYNC);
+    fd = open(com_path, O_RDWR | O_NOCTTY | O_SYNC);
     if (fd < 0) {
-        printf("ERROR: failed to open COM port %s - %s\n", portname, strerror(errno));
+        printf("ERROR: failed to open COM port %s - %s\n", com_path, strerror(errno));
     } else {
-        x = set_interface_attribs_linux(fd, B115200);
-        x |= set_blocking_linux(fd, true);
-        if (x != 0) {
-            printf("ERROR: failed to configure COM port %s\n", portname);
-            free(usb_device);
-            return LGW_COM_ERROR;
+        if( set_interface_attribs_linux(fd, B115200) != LGW_COM_SUCCESS ||
+            set_blocking_linux(fd, false) != LGW_COM_SUCCESS ) {
+            printf("ERROR: failed to configure COM port %s\n", com_path);
+            goto fail;
         }
 
         *usb_device = fd;
         *com_target_ptr = (void*)usb_device;
 
-        return LGW_COM_SUCCESS;
+        uint8_t eui[8];
+        int tries = 0;
+        do {
+            int err = lgw_mcu_get_unique_id(eui);  // NOTE: uses *com_target_ptr!
+            if( err == LGW_MCU_SUCCESS ) {
+                if( set_blocking_linux(fd, true) != LGW_COM_SUCCESS ) {
+                    printf("ERROR: failed to configure COM port %s\n", com_path);
+                    goto fail;
+                }
+                return LGW_COM_SUCCESS;
+            }
+        } while( ++tries < 4 );
     }
-
+  fail:
+    close(fd);
     free(usb_device);
+    *com_target_ptr = NULL;
     return LGW_COM_ERROR;
 }
 
